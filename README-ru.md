<p align="center">
  <img src="Docs/banner.png" alt="Letopis Logo" width="600"/>
</p>

<p align="center">
  <a href="https://swift.org">
    <img src="https://img.shields.io/badge/Swift-6.2-orange.svg?logo=swift" />
  </a>
  <a href="https://swift.org/package-manager/">
    <img src="https://img.shields.io/badge/SPM-compatible-green.svg" />
  </a>
  <img src="https://img.shields.io/badge/platforms-iOS%20%7C%20macOS%20%7C%20Linux-blue.svg" />
  <a href="LICENSE">
    <img src="https://img.shields.io/badge/license-MIT-lightgrey.svg" />
  </a>
</p>

# Letopis

*Читать на других языках: [English](README.md)*

`Letopis` — это легковесный модуль для логирования и трейсинга, который позволяет
описывать события приложения через декларативный API и доставлять их через цепочку
интерцепторов. Пакет не имеет внешних зависимостей, поэтому может использоваться
на любом уровне вашего кода.

А также вы можете использовать данную библиотеку как пример архитектуры для построения свои логгеров.
Не обязательно завязываться именно на конкретную реализацию.

## Ключевые возможности

- **Единая точка входа для логирования.** Один и тот же фасад отправляет события
  как в консоль, так и по сети, а через интерцепторы вы можете подключать любые
  внешние сервисы: системы аналитики, мониторинга или собственные бекенды.
  Разработчик продолжает работать с единым API и не думает о конкретных
  каналах доставки.
- **Расширяемая архитектура через интерцепторы.** В каждый интерцептор можно
  инкапсулировать свою логику фильтрации и маршрутизации, задавать индивидуальные
  приоритеты и реализовывать кастомные сценарии отправки сообщений.
- **Гибкое управление сетевым трафиком.** Сетевые интерцепторы могут анализировать
  состояние соединения, решать, отправлять ли событие сразу или сохранять его в
  буфере, а при переполнении — перенаправлять данные во внешнее хранилище или
  библиотеку для отложенной обработки.
- **Адаптация к внешним условиям.** Логгер динамически подстраивается под
  состояние сети и другие ограничения среды, а поведение можно тонко
  настраивать извне, добавляя собственные интерцепторы без изменения ядра.

## Какие еще проблемы можно решить данным логгером:

Например, в проектах часто встречается разделение логера и аналитики.
И в итоге мы в коде видим что-то на подобии
```swift
...
    analyticsFacade.sendEvent(.someEvent) // отправляем метод в аналитику
    logger.log("Отправили аналитику с событием .someEvent")
...
```

И получается мы дополнительно аналитику обкладываем логами. Хотя по факту это очень похожие вещи.
В данной библиотеке мы можем это объединить. Просто расширяем логгер, добавляя соответствующий интерцептор.
Который может быть тем же фасадом. Только теперь разработчик может сократить много времени настроим логгер вначале.

```swift
    logger.analytics(.someEvent, ...)
```

И дальше событие уходит и в аналитику и в консоль (если захотим) и может быть проигнорированно сетевыми логерами.

## Ключевые сущности

- **`Letopis`** — фасад, который создает события и распределяет их между
  интерцепторами. Принимает начальный массив `LetopisInterceptor` и может
  расширяться во время выполнения через `addInterceptor(_:)`.
- **`Log`** — билдер, который позволяет описать событие через цепочку вызовов
  перед его отправкой.
- **`LogEvent`** — DTO, содержащее идентификатор, временную метку, тип лога
  (`LogEventType`), приоритет (`LogPriority`), сообщение и дополнительный
  словарь `payload`.
- **`EventTypeProtocol` / `EventActionProtocol`** — протоколы для семантических
  классификаторов событий. Вы можете создать собственные типы,
  соответствующие этим протоколам.
- **`LetopisInterceptor`** — протокол для обработчиков, которые решают, что
  делать с событиями (отправлять по сети, сохранять, фильтровать и т.д.).

## Быстрый старт


```swift
import Letopis

// Определите собственные типы событий
// Подпишите enum под протокол.
enum AppEventType: String, EventTypeProtocol {
    case userAction = "user_action"
    case apiCall = "api_call"
    case error = "error"
    case system = "system"
}

// А также действия. Это тоже enum подписанн под соответствующий протокол.
enum AppEventAction: String, EventActionProtocol {
    case view = "view"
    case fetch = "fetch"
    case networkFailure = "network_failure"
}

// Настройка логгера с консольным выводом для разработки
private let logger = Letopis(
    interceptors: [
        ConsoleInterceptor(
            // Можно указать события которые мы хотим явно прослушивать.
            // Иначе будем обрабатывать все.
            logTypes: [.info, .error],
            // С типами тоже самое
            eventTypes: ["user_action", "api_call", "error"],
            // И со свойствами тоже.
            priorities: [.default, .critical]
        )
    ]
)

// Логирование пользовательских действий
logger
    .event(AppEventType.userAction)
    .action(AppEventAction.view)
    .payload(["user_id": "12345", "screen": "profile"])
    .source() // Можно добавить строку откуда вызыван код (для дебага удобно)
    .info("Пользователь открыл экран профиля")

// Логирование API вызовов
logger
    .event(AppEventType.apiCall)
    .action(AppEventAction.fetch)
    .payload(["endpoint": "/api/users/12345", "method": "GET"])
    .info("Загрузка данных пользователя")

// Логирование ошибок с критическим приоритетом
logger
    .event(AppEventType.error)
    .action(AppEventAction.networkFailure)
    .priority(.critical)
    .payload(["error_code": "500", "retry_count": "3"])
    .error("Не удалось загрузить данные пользователя")

// Это debug событие будет отфильтровано
logger
    .event(AppEventType.system)
    .debug("Внутренний кэш обновлен")
```

В этом примере консольный интерцептор показывает только info и error сообщения,
связанные с действиями пользователя, API вызовами и ошибками. Debug сообщения
и другие типы событий фильтруются.

## API модуля

### Билдер `Log`

- `action(_:)` / `event(_:)` — устанавливают семантическое действие и тип
  события. Принимают любые типы, соответствующие `EventActionProtocol` /
  `EventTypeProtocol`, или произвольный строковый литерал.
- `payload(_:)` — объединяет дополнительные пары ключ-значение в payload события.
- `priority(_:)` — изменяет приоритет доставки (`.default` или `.critical`).
- `source(file:function:line:)` — записывает информацию о месте вызова в payload.
  По умолчанию использует `#file`, `#function` и `#line` и сохраняет их под
  ключами `source_file`, `source_function` и `source_line`.
- `info(_:)`, `warning(_:)`, `error(_:)`, `debug(_:)`, `analytics(_:)` — устанавливают тип
  события, сообщение и немедленно создают и отправляют `LogEvent` всем
  интерцепторам. Ошибки можно передавать напрямую через
  `error(_ error: Error, ...)`.

Для краткого кода можно начинать билдер от фасада через вспомогательные методы
типа `skryzhal.event(...)` или `skryzhal.action(...)`.

### Прямые вызовы

Если билдер избыточен, вызывайте методы фасада напрямую:

```swift
// Логирование успешной покупки
logger.info(
    "Покупка завершена успешно",
    priority: .critical,
    payload: ["product_id": "premium_plan", "amount": "9.99", "currency": "USD"],
    eventType: .analytics,
    eventAction: .purchase
)

// Логирование сетевой ошибки
logger.error(
    "Сетевой запрос не выполнен",
    priority: .critical,
    payload: ["url": "https://api.example.com/data", "status_code": "404"],
    eventType: .error,
    eventAction: .networkFailure
)
```

Эквивалентные перегрузки существуют для `warning`, `debug`, `analytics` и двух версий
`error` (принимающих `String` или `Error`). Каждый метод принимает опциональные
аргументы `payload`, `eventType` и `eventAction`, которые объединяются в
финальный payload.

### Собственные типы событий

Вы можете создать собственные типы событий, соответствующие протоколам:

```swift
enum CustomEventType: String, EventTypeProtocol {
    case authentication = "auth"
    case dataSync = "data_sync"
    case featureFlag = "feature_flag"
}

enum CustomAction: String, EventActionProtocol {
    case enable = "enable"
    case disable = "disable"
    case refresh = "refresh"
}

// Используйте их с логгером
logger
    .event(CustomEventType.authentication)
    .action(CustomAction.enable)
    .info("Двухфакторная аутентификация включена")
```

### Пример интеграции

При создании пакета или приложения с Letopis в качестве зависимости, вы можете определить собственные типы событий и действий для вашей предметной области:

```swift
import Letopis
import Foundation

public enum ScreenAction: String, EventActionProtocol, Sendable {
    case open
    case close
}

public enum AppEventType: String, EventTypeProtocol, Sendable {
    case uiAction = "ui_action"
    case businessLogic = "business_logic"
}

@main
struct LetopisDemo {
    static func main() {
        let logger = Letopis(interceptors: [ConsoleInterceptor()])

        logger
            .event(AppEventType.uiAction)
            .action(ScreenAction.open)
            .payload(["screen_name": "MainViewController", "user_id": "12345"])
            .source()
            .info("Пользователь открыл главный экран")

        logger
            .event(AppEventType.businessLogic)
            .payload(["operation": "data_sync", "records_count": "150"])
            .source()
            .info("Обработка пользовательских данных")

        // Даем время на обработку и вывод логов
        Thread.sleep(forTimeInterval: 2.0)
    }
}
```

Такой подход позволяет создавать специфичные для предметной области таксономии событий, которые имеют смысл для вашего приложения, используя при этом гибкую инфраструктуру логирования Letopis.

## Продвинутые примеры

### Сетевой интерцептор с кэшированием

Полный пример реализации сетевого интерцептора с кэшированием и мониторингом подключения см. в [`Demo.swift`](Sources/Letopis/Examples/Demo.swift). Этот пример демонстрирует:

- **Потокобезопасный интерцептор на основе актора** для обработки сетевых логов
- **Умное кэширование**, которое сохраняет логи в офлайне и обрабатывает их при восстановлении подключения
- **Обработку по приоритету**, где критические логи отправляются даже при плохом соединении
- **Мониторинг состояния сети** с различным поведением для онлайн, офлайн и плохого подключения
- **Реальные сценарии**, включая сбои сервера и логику повторов

Демо показывает, как создавать production-ready интерцепторы, которые адаптируются к изменяющимся сетевым условиям, сохраняя целостность данных и пользовательский опыт.

## Интерцепторы и расширяемость

### Базовый протокол

Для соответствия `LetopisInterceptor` реализуйте единственный метод
`handle(_ logEvent: LogEvent)`. После вызова вы можете:

- обрабатывать событие синхронно или асинхронно;
- отбрасывать его, если оно не соответствует вашим правилам (например,
  фильтровать по типу, приоритету или метаданным);
- трансформировать payload и пересылать в другую систему.

### Консольный интерцептор

`ConsoleInterceptor` — готовая к использованию реализация, которая может
фильтровать события по типу лога, приоритету, семантическим значениям и
исходному файлу. Фильтры предоставляются как массивы, которые нормализуются
в множества. Интерцептор форматирует события в строку и выводит их с помощью
замыкания `Printer` (по умолчанию `print`). Вывод выполняется на глобальном
акторе `LoggingActor` для последовательности консольного вывода.

> ℹ️  Фильтр `sourceFiles` ищет в payload поле `source_file`, в котором хранится
> имя исходного файла, и сравнивает его со списком допустимых значений. Билдеры,
> формирующие собственный payload, могут заполнять этот ключ вручную при
> необходимости.

В не-`DEBUG` сборках `ConsoleInterceptor` работает вхолостую и подавляет вывод.

### Собственные каналы доставки

Чтобы добавить новый канал доставки:

1. Создайте тип, соответствующий `LetopisInterceptor`.
2. Решите, какие события вы хотите обрабатывать (например, `priority == .critical`
   для немедленной загрузки).
3. Реализуйте базовую инфраструктуру: сетевой клиент, файловый менеджер или
   слой базы данных.

Упрощенный сетевой интерцептор может выглядеть так:

```swift
final class AnalyticsInterceptor: LetopisInterceptor {
    private let analyticsService: AnalyticsService

    init(analyticsService: AnalyticsService) {
        self.analyticsService = analyticsService
    }

    func handle(_ logEvent: LogEvent) {
        // Отправляем только события аналитики и пользовательских действий
        guard let eventType = logEvent.payload["event_type"],
              ["analytics", "user_action"].contains(eventType) else { return }

        let analyticsEvent = AnalyticsEvent(
            name: logEvent.message,
            properties: logEvent.payload,
            timestamp: logEvent.timestamp
        )

        analyticsService.track(analyticsEvent)
    }
}
```

Тот же подход работает для сохранения на диск (например, запись JSON) или
баз данных (Core Data, Realm, SQLite, …). Каждый интерцептор инкапсулирует
собственное хранилище и политику повторов, поэтому их можно свободно комбинировать.

## Приоритизация событий

`LogPriority` определяет два уровня:

- `.default` — обычные события, которые можно буферизовать или отправлять пакетами.
- `.critical` — события, требующие немедленной обработки (сбои, критическая
  аналитика).

Каждый интерцептор может интерпретировать приоритеты по-разному. Примеры:

- сетевой интерцептор может отправлять критические события немедленно, а
  остальные ставить в очередь;
- дисковый интерцептор может сохранять все, но запускать фоновую синхронизацию
  только при появлении критической записи;
- консольный интерцептор может печатать только высокоприоритетные сообщения,
  скрывая шум.

Это выносит приоритизацию за пределы ядра и позволяет каждому каналу доставки
следовать собственным правилам.

## Комбинирование интерцепторов

`Letopis` поддерживает несколько интерцепторов одновременно, позволяя
смешивать и сочетать обработчики для разных окружений:

```swift
// Продакшен-настройка с несколькими каналами доставки
let logger = Letopis(
    interceptors: [
        ConsoleInterceptor(logTypes: [.error]), // Только ошибки в консоль
        AnalyticsInterceptor(analyticsService: mixpanel), // События пользователей в аналитику
        CrashReportingInterceptor(crashlytics: crashlytics), // Критические ошибки в краш-репорты
        LocalStorageInterceptor(storage: coreDataStack) // Все события в локальную базу
    ]
)

// Настройка для разработки
#if DEBUG
let devLogger = Letopis(
    interceptors: [
        ConsoleInterceptor() // Все события в консоль для отладки
    ]
)
#endif
```

Вызов любого метода логирования (`info()`, `warning()`, `error()`, `debug()`, `analytics()`)
создает событие, которое передается каждому интерцептору по очереди, поэтому
добавление нового канала доставки не требует изменения существующих.

## Советы по внедрению

- Поддерживайте согласованность ключей payload между интерцепторами (например,
  `event_type`, `event_action`, `source_*`).
- Используйте enums с `String` raw values для описания типов событий и действий
  типобезопасным способом.
- Размещайте конкретные реализации интерцепторов (сеть, файлы, база данных)
  в отдельных модулях или слоях для лучшей модульности.
- Покрывайте интерцепторы тестами. `LetopisTests` содержит пример шпионского
  интерцептора, который проверяет доставку событий.

Используйте эту документацию как отправную точку и адаптируйте `Letopis` под
нужды вашего проекта, добавляя собственные интерцепторы и политики доставки,
сохраняя при этом согласованность интерфейса логирования.

## Лицензия

Этот проект лицензирован под MIT License — подробности см. в файле [LICENSE](LICENSE).
